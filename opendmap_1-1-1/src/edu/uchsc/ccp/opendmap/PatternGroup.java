/**
 * The OpenDMAP for Protege Project
 * August 2005
 */
package edu.uchsc.ccp.opendmap;

import java.util.Collection;
import java.util.Vector;

/**
 * A <code>PatternGroup</code> is a collection of pattern fragments
 * that are all waiting for the same next parser item to be recognized.
 * <p>
 * In effect, a <code>PatternGroup</code> behaves like a single
 * normalized pattern.  However, when advanced it sorts the new pattern
 * fragments according to what they are waiting for and keeps those
 * waiting for the same thing in a single group rather than splitting
 * them all out separately.
 * <p>
 * Pattern groups were introduced to prevent redundant recognitions
 * when a pattern split into several different normalized variants.
 * 
 * @author R. James Firby
 */

/* Changes (most recent first)
 * 
 * 09-15-05 rjf - Changed toString() to display more internal information
 *                 about the patterns in the group
 */
public class PatternGroup {
	
	private static final String DISCONTINUOUS_MARKER = "_";
	
	/* The collection of patterns held in this group */
	private Vector<Pattern> group = new Vector<Pattern>();
	/* The common key and base item all the patterns share */
	private DMAPItem key = null;
	private DMAPItem base = null;
	
	/* Whether this pattern group was generated by a "discontinuous" marker */
	private boolean discontinuous = false;
	
	/**
	 * Creates a new pattern group for the supplied pattern.
	 * The pattern must be normalized.
	 * 
	 * @param pattern The pattern starting the group.
	 */
	private PatternGroup(Pattern pattern) {
		group.add(pattern);
		if (pattern.isNormalized()) {
			key = pattern.getKey();
			base = pattern.getContent();
		} else {
			throw new Error("A pattern group must be constructed soley from normalized patterns.");
		}
	}
	
	/**
	 * Get the content item that the key for this pattern group
	 * is waiting to recognize.
	 * 
	 * @return The base content item for this group.
	 */
	public DMAPItem getContent() {
		return base;
	}
	
	/**
	 * Predicate to tell if this pattern group is normalized or not.
	 * <p>
	 * A normalized pattern group has been massaged to be 
	 * expecting a single recognizable parser item.
	 * 
	 * @return Whether this pattern group has been normalized
	 */
	public boolean isNormalized() {
		return (key != null);
	}
	
	/**
	 * Get the element that this normalized pattern group is
	 * waiting for.
	 * 
	 * @return The normalized base element
	 */
	public DMAPItem getKey() {
		return key;
	}
	
	public boolean isDiscontinuous() {
		return discontinuous;
	}

	/**
	 * Process a pattern to find the first base element that it is
	 * waiting for. There may, in fact, be many possible base elements so 
	 * this method may return a collection of new pattern groups, each normalized 
	 * to a different element.
	 * <p>
	 * This method may copy as much or as little of the pattern as required.
	 * 
	 * @return The normalized pattern groups for this pattern.
	 */
	static Collection<PatternGroup> normalize(Pattern pattern) {
		// Process the pattern as required to create a set of
		// normalized patterns.  Sort into pattern groups with
		// the same key.
		Vector<PatternGroup> result = new Vector<PatternGroup>();
		if (pattern.isNormalized()) {
			// Already normalized, add into group
			sortIntoGroups(result, pattern);
		} else {
			// Not normalized, normalize and sort into groups
			Collection<Pattern> patterns = pattern.normalize();
			for (Pattern p: patterns) {
				sortIntoGroups(result, p);
			}
		}
		// If one of the groups is discontinuous, label and advance
		handleDiscontinuousGroups(result);
		// Done
		return result;
	}

	/**
	 * Advancing a pattern group moves it forward to the next base element that
	 * the parser should be looking for.  Advancing a pattern generates only
	 * normalized results.  Thus, advancing a pattern group may also generate an
	 * arbitrary number of new pattern groups.
	 * 
	 * @return The new, advanced, normalized versions of this pattern group
	 */
	public Collection<PatternGroup> advance() {
		assert(isNormalized()) : "Only normalized pattern groups can be advanced.";
		// Advance each pattern as required to create a set of
		// normalized patterns.  Sort into pattern groups with
		// the same key.
		boolean foundNull = false;
		Vector<PatternGroup> result = new Vector<PatternGroup>();
		for (Pattern pattern: group) {
			Collection<Pattern> patterns = pattern.advance();
			if (patterns == null) {
				foundNull = true;
			} else {
				for (Pattern p: patterns) {
					if (p == null) {
						foundNull = true;
					} else {
						sortIntoGroups(result, p);
					}
				}
			}
		}
		// If one of the groups is discontinuous, label and advance
		handleDiscontinuousGroups(result);
		// Done
		if (foundNull && !result.isEmpty()) sortIntoGroups(result, null);
		if (result.isEmpty()) {
			return null;
		} else {
			return result;
		}
	}
	
	/**
	 * Test whether there are subpatterns in this PatternGroup to be matched.
	 * @return the maximum number of subpatterns of any Pattern in this group.
	 */
	public int testAdvance() {
		int max = 0;
		for (Pattern pattern: group) {
			int patternSubs = pattern.testAdvance();
			if ( patternSubs > max ) {
				max = patternSubs;
			}
		}

		return max;
	}
	
	private static void handleDiscontinuousGroups(Collection<PatternGroup> groups) {
		PatternGroup tagged = null;
		for (PatternGroup group: groups) {
			DMAPItem key = group.getContent();
			if ((key instanceof TextItem) && (key.getText().equalsIgnoreCase(DISCONTINUOUS_MARKER))) {
				tagged = group;
				break;
			}
		}
		if (tagged != null) {
			Collection<PatternGroup> newGroups = tagged.advance();
			if (newGroups == null) {
				sortIntoGroups(groups, null);
			} else {
				for (PatternGroup group: newGroups) {
					if (group == null) {
						sortIntoGroups(groups, null);
					} else {
						group.discontinuous = true;
						groups.add(group);
					}
				}
			}
		}
	}

	/**
	 * Sort a pattern into a set of pattern groups.  A pattern
	 * belongs in the same group if it has the same key and the
	 * same base item as the group.
	 * 
	 * @param groups The set of groups to sort into
	 * @param pattern The new pattern to be sorted in
	 */
	private static void sortIntoGroups(Collection<PatternGroup> groups, Pattern pattern) {
		if (pattern == null) {
			// Treat the 'optional' marker in a special way
			if (!groups.contains(null)) {
				groups.add(null);
			}
		} else {
			// See if any existing group holds the key
			for (PatternGroup g: groups) {
				if (g != null) {
					if ((g.key == pattern.getKey()) && (g.base == pattern.getContent())) {
						// Same key means same group
						g.group.add(pattern);
						return;
					}
				}
			}
			// Need to add a new group
			groups.add(new PatternGroup(pattern));
		}
	}

	/**
	 * Return the pattern group as a string
	 */
	public String toString() {
		if (group.size() <= 0) {
			return "";
		} else if (group.size() == 1) {
			return group.get(0).toString();
		} else {
			StringBuffer sb = new StringBuffer();
			sb.append("pg(");
			boolean first = true;
			for (Pattern p: group) {
				if (!first) sb.append(", ");
				sb.append(p.toString());
				first = false;
			}
			return sb.toString();
			//return "(Pattern Group #" + this.hashCode() + ")";
		}
	}
	
}