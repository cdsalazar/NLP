/**
 * The OpenDMAP for Protege Project
 * March 2005
 */
package edu.uchsc.ccp.opendmap;

import java.awt.FontMetrics;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Map;
import java.util.Vector;
import java.util.logging.Level;

import javax.swing.JPanel;

import edu.stanford.smi.protege.model.Cls;
import edu.stanford.smi.protege.model.Frame;
import edu.stanford.smi.protege.model.Instance;
import edu.stanford.smi.protege.model.KnowledgeBase;
import edu.stanford.smi.protege.model.SimpleInstance;
import edu.stanford.smi.protege.model.Slot;
import edu.uchsc.ccp.opendmap.PredictionManager.PredictionIterator;
//import edu.uchsc.ccp.opendmap.debug.ReferenceListTabbedPane;
import edu.uchsc.ccp.opendmap.pattern.ParseException;

/**
 * The parser is the main entry point into the OpenDMAP system.
 * <p>
 * A parser connects a Protege Knowledge Base with a set of recognition patterns, which may come from a file or from the knowledge base. After loading
 * this information, the parser can be used to look for references to Protege Frames in an input text.
 * <p>
 * When the parser "parses" an input text, it records all of the references to various Protege Frames, and other recognizable elements, that it finds
 * in the text. These references are essentially descriptions of possible Protege Frame instances that might have been made in the text. Further
 * non-DMAP processing is needed to decide what to do with these references.
 * 
 * @author Will Fitzgerald
 * @author R. James Firby
 */

/*
 * Changes (most recent first) -----------------------------------------------------------------------------------------------------------------
 * 11-29-30 wab - Updated due to change in Reference so that each Reference keeps track of the Prediction that "created" it --------------------
 * 05-03-06 rjf - Added property function handlers (replacing PhraseGraphs) --------------------------------------------------------------------
 * 02-01-06 rjf - Added token lists to References ----------------------------------------------------------------------------------------------
 * 02-01-06 rjf - Changed subsumption to include properties and strictness ---------------------------------------------------------------------
 * 12-13-05 rjf - Added Protege Project Groups to support cross-project inference --------------------------------------------------------------
 * 12-05-05 rjf - Added reference handlers to process references when recognized ---------------------------------------------------------------
 * 11-29-05 rjf - Added configuration files as a way to configure the parser -------------------------------------------------------------------
 * 10-12-05 rjf - Moved default tokenizer to DefaultTokenizer class, added start and end character positions -----------------------------------
 * 09-28-05 rjf - Added slot path handling -----------------------------------------------------------------------------------------------------
 * 09-27-05 rjf - Fixed '.' handling in default tokenizer --------------------------------------------------------------------------------------
 * 09-23-05 rjf - Changed default for retainCase to false --------------------------------------------------------------------------------------
 * 09-15-05 rjf - Added a little bit more indenting in logged output ---------------------------------------------------------------------------
 */
public class Parser {

    public static boolean DEFAULT_RETAIN_CASE = false;

    /* TODO: Figure out how to do logging and tracing in a better way */
    private DMAPLogger logger = null;

    /* The Protege Project Group that ties all projects together into a coherent whole */
    private ProtegeProjectGroup protegeProjectGroup = null;

    /* The prediction manager keeps track of predictions generated by DMAP */
  	protected PredictionManager predictionManager = null;

    /* Whether or not this parser should pay attention to, or ignore, case when matching text strings */
    private boolean retainCase = DEFAULT_RETAIN_CASE;

    /* A list of DMAPPropertyFunctionHandlers to process slot path constraints */
    private Collection<DMAPPropertyFunctionHandler> propertyHandlers = null;

    /* The table of reference handlers defined by the end user */
    private HandlerTable handlers = null;

    /* A record of all the references identified in the input text */
    private Vector<Reference> references = new Vector<Reference>();

    /* The current token count */
    private int tokenCount = 0;

    /* Some debugging informational counters */
    private int slotPatternCount = 0;

    /**
     * Create a new <code>Parser</code>.
     * <p>
     * This parser contains no patterns and does logging as specified in the standard Java logging utility configuration files.
     */
    public Parser() {
        this(DEFAULT_RETAIN_CASE, null);
    }

    /**
     * Create a new <code>Parser</code>.
     * <p>
     * This parser contains no patterns and does logging as specified in the standard Java logging utility configuration files.
     * 
     * @param retainCase
     *            True if this parser should pay attention to case in text strings, False if case should be ignored.
     */
    public Parser(boolean retainCase) {
        this(retainCase, null);
    }

    /**
     * Create a new <code>Parser</code>.
     * <p>
     * This parser contains no patterns, does logging as specified in the standard Java logging utility configuration files, and produces an output
     * trace to System.out at the level of interest specified.
     * 
     * @param level
     *            The tracing level for this parser.
     */
    public Parser(Level level) {
        this(DEFAULT_RETAIN_CASE, level);
    }

    /**
     * Create a new <code>Parser</code>.
     * <p>
     * This parser contains no patterns, does logging as specified in the standard Java logging utility configuration files, and produces an output
     * trace to System.out at the level of interest specified.
     * 
     * @param retainCase
     *            True if this parser should pay attention to case in text strings, False if case should be ignored.
     * @param level
     *            The tracing level for this parser.
     */
    public Parser(boolean retainCase, Level level) {
        if (level != null) {
            logger = new DMAPLogger(this.getClass().getName(), level);
        } else {
            logger = new DMAPLogger(this.getClass().getName());
        }
        predictionManager = new PredictionManager(this);
        protegeProjectGroup = new ProtegeProjectGroup();
        handlers = new HandlerTable();
        this.retainCase = retainCase;
    }

    /**
     * Check whether logging or tracing output is being generated for the specified level.
     * 
     * @param level
     *            The logging level to check.
     * @return True if output will be generated for this level.
     */
    public boolean isLoggable(Level level) {
        return logger.isLoggable(level);
    }

    /**
     * Log a message according to the standard Java logging rules and produce tracing output if desired.
     * 
     * @param level
     *            The level at which to log this message.
     * @param message
     *            The message to log.
     */
    public void log(Level level, String message) {
        logger.log(level, message);
    }

    /**
     * Get the logger being used by this parser.
     * 
     * @return The logger being used by this parser.
     */
    public DMAPLogger getLogger() {
        return logger;
    }

    /**
     * Get the prediction manager this parser is using. Required by the pattern parsing classes.
     * 
     * @return The prediction manager
     */
    protected PredictionManager getPredictionManager() {
        return predictionManager;
    }

    /**
     * Get the Protege project group used by this parser. Required by the configuration loading code.
     * 
     * @return The protege project group.
     */
    public ProtegeProjectGroup getProtegeProjectGroup() {
        return protegeProjectGroup;
    }

    /**
     * Get the slot path property function handlers being used by this parser. These are reset each time the parser is reset.
     * 
     * @return The property function handlers.
     */
    public Collection<DMAPPropertyFunctionHandler> getPropertyFunctionHandlers() {
        return propertyHandlers;
    }

    /**
     * Clear the parsing state and and references recognized so far.
     * <p>
     * If the argument is supplied as 'true', then all anytime predictions will be removed and the recognition patterns will have to be loaded into
     * the parser over again.
     * 
     * @param all
     *            True to erase all known patterns, false to clear only dynamic state.
     */
    public void clear(boolean all) {
        predictionManager.clear(all);
        propertyHandlers = null;
        references = new Vector<Reference>();
        tokenCount = 0;
    }

    /**
     * Reset the parser for new input. This method is equivalent to clear(false).
     * <p>
     * This is the recommended way of resetting the parser between calls to parse input strings.
     */
    public void reset() {
        clear(false);
    }

    /**
     * Parse an input string to extract all the references.
     * 
     * @param string
     *            The input phrase to parse
     */
    public void parse(String string) {
        if (logger.isLoggable(Level.INFO)) {
            logger.log(Level.INFO, "Parsing input: \"" + string + "\"");
            logger.addIndent();
        }
        parse(new DefaultTokenizer(string, retainCase));
        if (logger.isLoggable(Level.INFO)) {
            logger.removeIndent();
            logger.log(Level.FINE, "Finished parsing input.");
        }
    }

    /**
     * Parse the input tokens taken from the supplied tokenizer object.
     * 
     * @param tokenizer
     *            The tokenizer object generating the input tokens.
     */
    public void parse(DMAPTokenizer tokenizer) {
        int offset = tokenCount;
        int newEnd = 0;
        if (tokenizer != null) {
            for (DMAPToken token : tokenizer) {
                if (token.getEnd() > newEnd) {
                    newEnd = token.getEnd();
                }
                token.setStart(token.getStart() + offset);
                token.setEnd(token.getEnd() + offset);
                Reference newReference = new Reference(token.getItem(), token.getStart(), token.getEnd(), 0, token.getInformation(), token
                        .getCharacterStart(), token.getCharacterEnd(), null);
                newReference.addToken(token);
                // reference(token.getItem(), tokenCount, tokenCount, 0, token.getInformation(), token.getStart(), token.getEnd());
                reference(newReference);
            }
        }
        tokenCount = tokenCount + newEnd;
    }

    /**
     * Parse the input tokens taken from the supplied tokenizer object with the supplied slot path property function handler in place.
     * 
     * @param tokenizer
     *            The tokenizer object generating the input tokens.
     * @param handler
     *            The property function handler.
     */
    public void parse(DMAPTokenizer tokenizer, DMAPPropertyFunctionHandler handler) {
        if (handler == null) {
            parse(tokenizer);
        } else {
            ArrayList<DMAPPropertyFunctionHandler> handlers = new ArrayList<DMAPPropertyFunctionHandler>(1);
            handlers.add(handler);
            parse(tokenizer, handlers);
        }
    }

    /**
     * Parse the input tokens taken from the supplied tokenizer object with the supplied slot path property function handlers in place.
     * 
     * @param tokenizer
     *            The tokenizer object generating the input tokens.
     * @param handlers
     *            The property function handlers.
     */
    public void parse(DMAPTokenizer tokenizer, Collection<DMAPPropertyFunctionHandler> handlers) {
        this.propertyHandlers = handlers;
        parse(tokenizer);
    }

    /**
     * Recognize a reference to a specific thing in the input. Advance any predictions waiting for this reference.
     * 
     * @param reference
     *            The reference just recognized
     */
    void reference(Reference reference) {
        // Add this reference to the list of references
        references.add(reference);
        // Now really 'recognize' it
        reference(reference.getItem(), reference);
    }

    private void reference(DMAPItem item, Reference reference) {
        // Log this reference
        if (logger.isLoggable(Level.FINE)) {
            int start = reference.getStart();
            int end = reference.getEnd();
            logger.log(Level.FINE, "Recognized " + item.toDescriptiveString() + " from " + start + " to " + end + ".");
            logger.addIndent();
        }
        // Advance all the predictions waiting for this reference
        advancePredictions(item, reference, false);
        DMAPItem denotation = reference.getDenotation();
        if (denotation != null) {
            advancePredictions(denotation, reference, true);
        }
        // If there are any special handlers for this reference, run them
        IReferenceHandler handler = handlers.get(item);
        if (handler != null) {
            if (logger.isLoggable(Level.FINER)) {
                logger.log(Level.FINER, "Invoking reference handler for " + item + " ...");
                logger.addIndent();
            }
            handler.handleReference(this, reference);
            if (logger.isLoggable(Level.FINER)) {
                logger.removeIndent();
                logger.log(Level.FINER, "Handler for " + item + " complete.");
            }
        }
        // Done
        if (logger.isLoggable(Level.FINE)) {
            logger.removeIndent();
        }
    }

    private void advancePredictions(DMAPItem item, Reference reference, boolean isDenotation) {
        // Get all the predictions waiting for this reference
        PredictionIterator j = predictionManager.getPredictionsOn(item);
        if (logger.isLoggable(Level.FINER)) {
            int start = reference.getStart();
            String itemName = item.toString();
            if (isDenotation) {
                itemName = itemName + " (denotation)";
            }
            if (j.hasNext()) {
                logger.log(Level.FINER, "Found " + j.numRemaining() + " predictions on " + itemName + " at " + start + ".");
            } else {
                logger.log(Level.FINER, "No predictions on " + itemName + " at " + start + ".");
            }
        }
        // Advance all the predictions
        while (j.hasNext()) {
            Prediction p = j.next();
            Vector<Prediction> dynamics = p.advance(reference, isDenotation);
            if (dynamics != null) {
                if (logger.isLoggable(Level.FINE)) {
                    logger.addIndent();
                }
                for (Prediction dynamic : dynamics) {
                    predictionManager.addDynamicPrediction(dynamic);
                }
                if (logger.isLoggable(Level.FINE)) {
                    logger.removeIndent();
                }
            }
        }

        if (logger.isLoggable(Level.FINER)) {
            logger.log(Level.FINER,
                    "----------------------------- Advanced Predictions - Prediction Manager output: -----------------------------");
            predictionManager.log(logger, Level.FINER);
            logger.log(Level.FINER, "--------------------------------------------------");
        }
    }

    /**
     * Add a new reference handler to the parser. This handler will be called when a reference to the specified Protege frame is recognized.
     * 
     * @param frame
     *            The Protege Frame
     * @param handler
     *            The handler to call when it is recognized
     */
    public void addReferenceHandler(Frame frame, IReferenceHandler handler) {
        handlers.add(frame, handler);
    }

    /**
     * Add patterns to the parser from a particular slot in a Protege knowledge base.
     * 
     * @param slotName
     *            The name of the slot holding the patterns
     * @param kb
     *            The Protege Knowledge Base holding the slot
     * @throws ParseException
     *             When there is an error parsing a pattern
     */
    @SuppressWarnings("unchecked")
    public void addPatternsFromProtegeSlot(String slotName, KnowledgeBase kb) throws ParseException {
        protegeProjectGroup.addKnowledgeBase(kb);
        // Do do some nice logging
        logger.log(Level.FINER, "Extracting patterns from Protege slots '" + slotName + "':");
        logger.addIndent();
        Slot slot = kb.getSlot(slotName);
        if (slot != null) {
            Collection<Frame> frames = (Collection<Frame>) kb.getFrames();
            for (Frame frame : frames) {
                if (frame instanceof Cls) {
                    Cls cls = (Cls) frame;
                    Collection values = cls.getOwnSlotValues(slot);
                    addPatternStrings(values, kb, frame, retainCase);
                } else if (frame instanceof SimpleInstance) {
                    SimpleInstance instance = (SimpleInstance) frame;
                    Collection values = instance.getOwnSlotValues(slot);
                    addPatternStrings(values, kb, frame, retainCase);
                }
            }
        }
        logger.removeIndent();
    }

    /**
     * Add patterns to the parser from a particular slot beneath a Protege Frame.
     * 
     * @param frameName
     *            The name of the frame to look under
     * @param slotName
     *            The name of the slot holding the patterns on the frame and its children
     * @param kb
     *            The Protege Knowledge Base holding the frame and slot
     * @throws ParseException
     *             When there is a problem parsing a pattern
     */
    @SuppressWarnings("unchecked")
    public void addPatternsFromProtegeFrame(String frameName, String slotName, KnowledgeBase kb) throws ParseException {
        if (frameName == null) {
            addPatternsFromProtegeSlot(slotName, kb);
        } else {
            protegeProjectGroup.addKnowledgeBase(kb);
            // Do do some nice logging
            logger.log(Level.FINER, "Extracting patterns from Protege slot '" + slotName + "' on frames of type '" + frameName + "':");
            logger.addIndent();
            Slot slot = kb.getSlot(slotName);
            if (slot != null) {
                Frame frame = kb.getFrame(frameName);
                if (frame != null) {
                    if (frame instanceof Cls) {
                        addProtegeClsSlotPatterns((Cls) frame, slot, kb);
                    } else if (frame instanceof SimpleInstance) {
                        SimpleInstance instance = (SimpleInstance) frame;
                        Collection values = instance.getOwnSlotValues(slot);
                        addPatternStrings(values, kb, frame, retainCase);
                    }
                }
            }
            logger.removeIndent();
        }
    }

    /**
     * Add patterns to the parser from the given Protege Cls and Slot.
     * 
     * @param cls
     *            The frame to look under
     * @param slot
     *            The slot holding the patterns under the frame
     * @param kb
     *            The Protege Knowledge Base holding the cls and slot
     * @throws ParseException
     *             When there is a problem parsing a pattern
     */
    @SuppressWarnings("unchecked")
    private void addProtegeClsSlotPatterns(Cls cls, Slot slot, KnowledgeBase kb) throws ParseException {
        // Get patterns from this class
        Collection values = cls.getOwnSlotValues(slot);
        addPatternStrings(values, kb, cls, retainCase);
        // Recursively look down the frame hierarchy
        for (Instance instance : (Collection<Instance>) cls.getInstances()) {
            values = ((SimpleInstance) instance).getOwnSlotValues(slot);
            addPatternStrings(values, kb, instance, retainCase);
        }
        // Recursively look down the frame hierarchy
        for (Cls subclass : (Collection<Cls>) cls.getSubclasses()) {
            values = subclass.getOwnSlotValues(slot);
            addPatternStrings(values, kb, cls, retainCase);
        }
    }

    /**
     * Add patterns to the parser from a collection of strings.
     * 
     * @param values
     *            The collection of strings, each one being a pattern
     * @param kb
     *            The Protege Knowledge Base associated with these patterns
     * @param baseF
     *            The base Protege Frame these patterns are for
     * @param retainCase
     *            True if the patterns should be case sensitive
     * @throws ParseException
     *             When there is a problem parsing a pattern
     */
    private void addPatternStrings(Collection values, KnowledgeBase kb, Frame baseF, boolean retainCase) throws ParseException {
        for (Object value : values) {
            if (value instanceof String) {
                Pattern pattern = null;
                try {
                    pattern = ASTConverter.readPatternFromString((String) value, kb, baseF.getBrowserText(), retainCase,
                            protegeProjectGroup);
                } catch (ParseException e) {
                    System.err.println("Warning: invalid pattern '" + value + "'");
                }
                if (pattern != null) {
                    predictionManager.addAnytimePrediction(new ProtegeFrameItem(baseF, protegeProjectGroup), pattern);
                    slotPatternCount = slotPatternCount + 1;
                    if (slotPatternCount == (slotPatternCount / 1000 * 1000)) {
                        System.err.println("Slot pattern " + slotPatternCount + " " + pattern.toPatternString());
                    }
                }
            }
        }
    }

    /**
     * Add recognition patterns to this parser from a string holding pattern rules.
     * 
     * @param patternRules
     *            The string holding the pattern rules to add.
     * @param kb
     *            The Protege Knowledge Base targetted by these rules.
     * @throws ParseException
     *             When there is a syntax error in the pattern rules.
     */
    public void addPatternsFromString(String patternRules, KnowledgeBase kb) throws ParseException {
        protegeProjectGroup.addKnowledgeBase(kb);
        // Do do some nice logging
        logger.log(Level.FINER, "Extracting patterns from string:");
        logger.addIndent();
        StringReader sr = new StringReader(patternRules);
        Reader r = new BufferedReader(sr);
        ASTConverter.addPredictionsFromRules(this, kb, r, retainCase, Level.FINER);
        logger.removeIndent();
    }

    /**
     * Add recognition patterns to this parser from a file holding pattern rules.
     * 
     * @param filename
     *            The name of the file holding the pattern rules.
     * @param kb
     *            The Protege Knowledge Base targetted by these rules.
     * @throws ParseException
     *             When there is a syntax error in the pattern rules.
     */
    public void addPatternsFromFile(String filename, KnowledgeBase kb) throws ParseException {
        protegeProjectGroup.addKnowledgeBase(kb);
        // Do do some nice logging
        logger.log(Level.FINER, "Extracting patterns from: " + filename);
        logger.addIndent();
        Reader r = null;
        try {
            FileReader sr = new FileReader(filename);
            r = new BufferedReader(sr);
        } catch (Exception e) {
            throw new ParseException(e.getMessage());
        }
        try {
        ASTConverter.addPredictionsFromRules(this, kb, r, retainCase, Level.FINER);
        } catch (ParseException e) {
        	throw new ParseException("Error while parsing file: " + filename + " -- " + e.getMessage());
        }
        logger.removeIndent();
    }

    /**
     * Get the set of references recognized by this parser since the last clear.
     * 
     * @return The set of references recognized by this parser.
     */
    public Collection<Reference> getReferences() {
        return references;
    }

    /**
     * Get the references recognized by this parser that correspond to Protege frames.
     * 
     * @return The Protege frame references recognized by the parser.
     */
    public Collection<Reference> getFrameReferences() {
        if (references == null)
            return null;
        Vector<Reference> results = new Vector<Reference>();
        for (Reference reference : references) {
            DMAPItem key = reference.getItem();
            if (key instanceof ProtegeFrameItem) {
                results.add(reference);
            }
        }
        return results;
    }

    /**
     * Get the references recognized by this parser that correspond to Protege frames that are <i>isa</i> the given class.
     * 
     * @param ancestorClass
     *            The class the references should be <i>isa</i>.
     * @return The Protege frame references recognized by the parser.
     */
    public Collection<Reference> getFrameReferences(String ancestorClass) {
        if (ancestorClass == null)
            return null;
        if (references == null)
            return null;
        Vector<Reference> results = new Vector<Reference>();
        for (Reference reference : references) {
            DMAPItem key = reference.getItem();
            if (key instanceof ProtegeFrameItem) {
                ProtegeFrameItem item = (ProtegeFrameItem) key;
                if (item.isa(ancestorClass))
                    results.add(reference);
            }
        }
        return results;
    }

    /**
     * Get all of the references recognized by the parser that correspond to single input words (string tokens).
     * 
     * @return The word references recognized by the parser.
     */
    public Collection<Reference> getWordReferences() {
        if (references == null)
            return null;
        Vector<Reference> results = new Vector<Reference>();
        for (Reference reference : references) {
            DMAPItem key = reference.getItem();
            if (key instanceof TextItem) {
                results.add(reference);
            }
        }
        return results;
    }

    /**
     * Get all of the references recognized by the parser that correspond to specified input word (string token).
     * 
     * @return The references to the given word recognized by the parser.
     */
    public Collection<Reference> getWordReferences(String word) {
        if (word == null)
            return null;
        if (references == null)
            return null;
        Vector<Reference> results = new Vector<Reference>();
        for (Reference reference : references) {
            DMAPItem key = reference.getItem();
            if (key instanceof TextItem) {
                if (word.equalsIgnoreCase(((TextItem) key).getText())) {
                    results.add(reference);
                }
            }
        }
        return results;
    }

    /**
     * Get all references recognized by the parser that span the entire input parsed since the last clear.
     * 
     * @return The spanning references recognized by the parser.
     */
    public Collection<Reference> getSpanningReferences() {
        if (references == null)
            return null;
        int last = tokenCount - 1;
        Vector<Reference> results = new Vector<Reference>();
        for (Reference r : references) {
            if ((r.getStart() == 0) && (r.getEnd() == last)) {
                results.add(r);
            }
        }
        return results;
    }

    /**
     * Get all references recognized by the parser that are not subsumed by another reference found by the parser
     * 
     * @return The unsubsumed references recognized by the parser.
     */
    public Collection<Reference> getUnsubsumedReferences() {
        return getUnsubsumedReferences(false);
    }

    public Collection<Reference> getUnsubsumedReferences(boolean debug) {
        if (references == null)
            return null;
        Vector<Reference> results = new Vector<Reference>();
        for (Reference r : references) {
            if (debug) {
                System.out.println();
                System.out.println("Considering:");
                System.out.println(r.getStart() + ".." + r.getEnd() + " " + r.getReferenceString());
            }
            if (!isSubsumed(r, references, debug)) {
                boolean found = false;
                for (int i = 0; i < results.size(); i++) {
                    Reference result = results.elementAt(i);
                    if (result.equals(r)) {
                        found = true;
                        if (r.getMissing() < result.getMissing())
                            results.setElementAt(r, i);
                        break;
                    }
                }
                if (!found)
                    results.add(r);
            }
        }
        return references;
    }

    private boolean isSubsumed(Reference r, Collection<Reference> references, boolean debug) {
        boolean subsumed = false;
        int rStart = r.getStart();
        int rEnd = r.getEnd();
        // Check each reference in the set to see if one subsumes r
        for (Reference s : references) {
            // A reference does not subsume itself
            if (s != r) {
                // s might subsume r, look at all the cases
                int sStart = s.getStart();
                int sEnd = s.getEnd();
                if ((sStart <= rStart) && (rEnd <= sEnd) && ((sStart != rStart) || (sEnd != rEnd))) {
                    // s spans a wider stretch of text than r
                    if (s.getMissing() <= 0) {
                        // s accounts for everything, r must be subsumed
                        subsumed = true;
                    } else {
                        // see if s accounts for everything in r
                        subsumed = s.subsumes(r, true);
                    }
                } else if ((sStart == rStart) && (sEnd == rEnd)) {
                    // s and r span the same stretch of text
                    if ((s.getMissing() <= 0) && (r.getMissing() <= 0) && s.subsumes(r, true)) {
                        // s and r account for all tokens and s subsumes r, s subsumes r unless they are equal
                        subsumed = !r.subsumes(s, true);
                    } else if ((s.getMissing() <= 0) && (r.getMissing() > 0)) {
                        // s accounts for everything and r doesn't, s subsumes r
                        return true;
                    } else if (s.getMissing() <= r.getMissing()) {
                        // s ignores fewer tokens, see if s accounts for everything in r
                        subsumed = s.subsumes(r, true);
                    }
                }
            }
            if (debug && subsumed) {
                System.out.println("Subsumed by:");
                System.out.println(s.getStart() + ".." + s.getEnd() + " " + s.getReferenceString());
            }
            if (subsumed)
                break;
        }
        return subsumed;
    }

    /**
     * Check if this parser has recognized a reference that <i>isa</i> the supplied class.
     * 
     * @param ancestorClass
     *            The class that a reference <i>isa</i>.
     * @return True if such a reference has been recognized.
     */
    public boolean hasFrameReference(String ancestorClass) {
        if (ancestorClass == null)
            return false;
        if (references == null)
            return false;
        boolean okay = false;
        for (Reference reference : references) {
            DMAPItem key = reference.getItem();
            if (key instanceof ProtegeFrameItem) {
                ProtegeFrameItem item = (ProtegeFrameItem) key;
                okay = item.isa(ancestorClass);
            }
            if (okay)
                break;
        }
        return okay;
    }

    /**
     * Check if this parser has recognized a word (input string token) that matches the supplied text.
     * 
     * @param word
     *            The word that might have been recognized.
     * @return True if that word has been recognized.
     */
    public boolean hasWordReference(String word) {
        if (word == null)
            return false;
        if (references == null)
            return false;
        boolean okay = false;
        for (Reference reference : references) {
            DMAPItem key = reference.getItem();
            if (key instanceof TextItem) {
                okay = word.equalsIgnoreCase(((TextItem) key).getText());
            }
            if (okay)
                break;
        }
        return okay;
    }

    public Reference newReference(String frameName, Collection<Object> slots) {
        if ((frameName != null) && (protegeProjectGroup != null)) {
            // Get the frame item
            Frame frame = protegeProjectGroup.getFrameByName(frameName);
            if (frame != null) {
                // Check all the slots to make sure they are InfoPackets
                Vector<InfoPacket> refSlots = new Vector<InfoPacket>();
                boolean okay = true;
                for (Object slot : slots) {
                    if (slot instanceof InfoPacket) {
                        refSlots.add((InfoPacket) slot);
                    } else {
                        okay = false;
                        break;
                    }
                }
                // Looks good, create a reference
                if (okay) {
                    ProtegeFrameItem item = new ProtegeFrameItem(frame, protegeProjectGroup);
                    return new Reference(item, 0, 0, 0, refSlots, 0, 0, null);
                }
            }
        }
        return null;
    }

    public Object newReferenceSlot(String frameName, String slotName, String value) {
        if ((value != null) && (frameName != null) && (slotName != null) && (protegeProjectGroup != null)) {
            // Get the Protege frame holding this slot
            Frame frame = protegeProjectGroup.getFrameByName(frameName);
            if (frame != null) {
                // Get the Protege slot
                KnowledgeBase kb = frame.getKnowledgeBase();
                Slot slot = kb.getSlot(slotName);
                if (slot != null) {
                    // Create a new slot item to name this slot
                    ProtegeSlotItem slotItem = new ProtegeSlotItem(slot, frame, protegeProjectGroup, false);
                    // Create a new text time to hold the value
                    TextItem slotValue = new TextItem(value);
                    // Verify that the value is a valid filler for the slot
                    if (slotItem.validFiller(slotValue)) {
                        // Build and InfoPacket for the slot
                        return new InfoPacket(slotItem, new Reference(slotValue, 0, 0, 0, null, 0, 0, null));
                    }
                }
            }
        }
        return null;
    }

    public Object newReferenceSlot(String frameName, String slotName, Reference value) {
        if ((value != null) && (frameName != null) && (slotName != null) && (protegeProjectGroup != null)) {
            // Get the Protege frame holding this slot
            Frame frame = protegeProjectGroup.getFrameByName(frameName);
            if (frame != null) {
                // Get the Protege slot
                KnowledgeBase kb = frame.getKnowledgeBase();
                Slot slot = kb.getSlot(slotName);
                if (slot != null) {
                    // Create a new slot item to name this slot
                    ProtegeSlotItem slotItem = new ProtegeSlotItem(slot, frame, protegeProjectGroup, false);
                    // Verify that the value is a valid filler for the slot
                    if (slotItem.validFiller(value.getItem())) {
                        // Build and InfoPacket for the slot
                        return new InfoPacket(slotItem, value);
                    }
                }
            }
        }
        return null;
    }

    /**
     * Added to enable visual debugging. - wab
     * @param r
     * @return
     */
    public Pattern getPatternUsedToMatchReference(Reference r) {
        return predictionManager.getPatternUsedToMatchReference(r);
    }
    
    public Map<String, Integer> getPattern2IDMap() {
        return predictionManager.getPatternToIDMap();
    }
 
    
    public Map<String, Prediction> getDynamicPredictions() {
        return predictionManager.getDynamicPredictions();
    }
    
    public String getParentPredictionHCForPredictionHC(String predictionHC) {
        return predictionManager.getParentForPrediction(predictionHC);
    }
    
    /*
     * This is a hook for the debug version to do things relating to 
     * displaying the prediction chain.
     */
    protected void inputAdvancingEvidence(String predHash, String predhash2, String text, boolean annotated, 
    		int start, int end) {
    	// null implementation here
    }
    protected void inputAdvancingEvidence(String predHash,  boolean annotated, 
    		int start, int end) {
    	// null implementation here
    }

}
