/* Generated By:JJTree&JavaCC: Do not edit this line. DMAPPatternParser.java */
package edu.uchsc.ccp.opendmap.pattern;

import edu.uchsc.ccp.opendmap.Pattern;

public class DMAPPatternParser/*@bgen(jjtree)*/implements DMAPPatternParserTreeConstants, DMAPPatternParserConstants {/*@bgen(jjtree)*/
  protected static JJTDMAPPatternParserState jjtree = new JJTDMAPPatternParserState();
  public static String trimName(String name) {
        return name.substring(1,name.length()-1);
  }
  public static String trimName(String name, int start) {
        return name.substring(start,name.length()-1);
  }

  public static void main(String args[]) throws ParseException {
    System.out.println("Reading from standard input...");
    DMAPPatternParser parser = new DMAPPatternParser(System.in);
    try {
      ASTDMAPRuleSet n = parser.DMAPRuleSet();
      n.dump("");
      System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }

/* Production rules. */

/* A DMAPRuleSet is a set of DMAP rules */
  static final public ASTDMAPRuleSet DMAPRuleSet() throws ParseException {
 /*@bgen(jjtree) DMAPRuleSet */
  ASTDMAPRuleSet jjtn000 = new ASTDMAPRuleSet(JJTDMAPRULESET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FRAME_NAME:
        case COMMENT:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FRAME_NAME:
          DMAPRule();
          break;
        case COMMENT:
          Comment();
          break;
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
     {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
    throw new Error("Missing return statement in function");
  }

/* A Comment is a comment token up to line end */
  static final public ASTComment Comment() throws ParseException {
 /*@bgen(jjtree) Comment */
  ASTComment jjtn000 = new ASTComment(JJTCOMMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(COMMENT);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/* A DMAPRule is a frame name, arrow, a set of patterns, ending with a semicolon */
/* 	  | Patterns() <SEMICOLON> ) */
  static final public ASTDMAPRule DMAPRule() throws ParseException {
 /*@bgen(jjtree) DMAPRule */
 ASTDMAPRule jjtn000 = new ASTDMAPRule(JJTDMAPRULE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      t = jj_consume_token(FRAME_NAME);
                            jjtn000.setBase(trimName(t.image));
      jj_consume_token(ARROW);
      Patterns();
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/* A set of patterns is one or more patterns separated by commas */
  static final public ASTPatterns Patterns() throws ParseException {
 /*@bgen(jjtree) Patterns */
  ASTPatterns jjtn000 = new ASTPatterns(JJTPATTERNS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      Pattern();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_2;
        }
        jj_consume_token(COMMA);
        Pattern();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/* Pattern => PatternHead (& Clause)* */
  static final public ASTPattern Pattern() throws ParseException {
 /*@bgen(jjtree) Pattern */
  ASTPattern jjtn000 = new ASTPattern(JJTPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      PatternComponent();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CLAUSE:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_3;
        }
        jj_consume_token(CLAUSE);
        PatternComponent();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/* A Pattern is one or more entries */
  static final public ASTPatternComponent PatternComponent() throws ParseException {
 /*@bgen(jjtree) PatternComponent */
  ASTPatternComponent jjtn000 = new ASTPatternComponent(JJTPATTERNCOMPONENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      label_4:
      while (true) {
        Entry();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case REGEX1:
        case REGEX2:
        case SYMBOL:
        case FRAME_NAME:
        case STRING1:
        case STRING2:
        case LBRACKET:
        case LPAREN:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_4;
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/* An entry is a base element, plus possible post-fixed operators or alternations. Optionally, surrounded by parens.*/
  static final public ASTEntry Entry() throws ParseException {
 /*@bgen(jjtree) Entry */
  ASTEntry jjtn000 = new ASTEntry(JJTENTRY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      OperatorEntry();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ALTERNATION:
        label_5:
        while (true) {
          jj_consume_token(ALTERNATION);
          OperatorEntry();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ALTERNATION:
            ;
            break;
          default:
            jj_la1[5] = jj_gen;
            break label_5;
          }
        }
                                                             jjtn000.setOperatorType(Pattern.Operator.ALTERNATION);
        break;
      default:
        jj_la1[6] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTEntry OperatorEntry() throws ParseException {
 /*@bgen(jjtree) OperatorEntry */
  ASTOperatorEntry jjtn000 = new ASTOperatorEntry(JJTOPERATORENTRY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      SimpleEntry();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KLEENE_STAR:
      case KLEENE_PLUS:
      case OPTIONAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case KLEENE_STAR:
          jj_consume_token(KLEENE_STAR);
                                            jjtn000.setOperatorType(Pattern.Operator.STAR);
          break;
        case KLEENE_PLUS:
          jj_consume_token(KLEENE_PLUS);
                                            jjtn000.setOperatorType(Pattern.Operator.PLUS);
          break;
        case OPTIONAL:
          jj_consume_token(OPTIONAL);
                                         jjtn000.setOperatorType(Pattern.Operator.OPTIONAL);
          break;
        default:
          jj_la1[7] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTEntry SimpleEntry() throws ParseException {
 /*@bgen(jjtree) SimpleEntry */
  ASTSimpleEntry jjtn000 = new ASTSimpleEntry(JJTSIMPLEENTRY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REGEX1:
      case REGEX2:
      case SYMBOL:
      case FRAME_NAME:
      case STRING1:
      case STRING2:
      case LBRACKET:
        BaseElement();
                          jjtn000.setOperatorType(Pattern.Operator.BASE);
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        label_6:
        while (true) {
          Entry();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case REGEX1:
          case REGEX2:
          case SYMBOL:
          case FRAME_NAME:
          case STRING1:
          case STRING2:
          case LBRACKET:
          case LPAREN:
            ;
            break;
          default:
            jj_la1[9] = jj_gen;
            break label_6;
          }
        }
        jj_consume_token(RPAREN);
                                            jjtn000.setOperatorType(Pattern.Operator.SEQUENCE);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/* Base element is a string, symbol, regular expression, frame name, or path */
  static final public ASTBaseElement BaseElement() throws ParseException {
 /*@bgen(jjtree) BaseElement */
  ASTBaseElement jjtn000 = new ASTBaseElement(JJTBASEELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING1:
        t = jj_consume_token(STRING1);
                         jjtn000.setEntryType(ASTBaseElement.EntryType.STRING);
                        jjtn000.setImage(trimName(t.image));
        break;
      case STRING2:
        t = jj_consume_token(STRING2);
                         jjtn000.setEntryType(ASTBaseElement.EntryType.STRING);
                        jjtn000.setImage(trimName(t.image));
        break;
      case SYMBOL:
        t = jj_consume_token(SYMBOL);
                        jjtn000.setEntryType(ASTBaseElement.EntryType.STRING);
                        jjtn000.setImage(t.image);
        break;
      case REGEX1:
        t = jj_consume_token(REGEX1);
                         jjtn000.setEntryType(ASTBaseElement.EntryType.REGEX);
                        jjtn000.setImage(trimName(t.image,2));
        break;
      case REGEX2:
        t = jj_consume_token(REGEX2);
                   jjtn000.setEntryType(ASTBaseElement.EntryType.REGEX);
                        jjtn000.setImage(trimName(t.image,2));
        break;
      case FRAME_NAME:
        t = jj_consume_token(FRAME_NAME);
                            jjtn000.setEntryType(ASTBaseElement.EntryType.FRAME_NAME);
                        jjtn000.setImage(trimName(t.image));
        break;
      case LBRACKET:
        Path();
                  jjtn000.setEntryType(ASTBaseElement.EntryType.PATH);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTSlotName SlotName() throws ParseException {
 /*@bgen(jjtree) SlotName */
  ASTSlotName jjtn000 = new ASTSlotName(JJTSLOTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t = null;
    try {
      t = jj_consume_token(SYMBOL);
                   jjtn000.setName(t.image);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
   {if (true) return jjtn000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
    throw new Error("Missing return statement in function");
  }

/* A path is one or more slot names  surrounded by brackets */
  static final public ASTPath Path() throws ParseException {
 /*@bgen(jjtree) Path */
  ASTPath jjtn000 = new ASTPath(JJTPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACKET);
      SlotName();
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SYMBOL:
        case KLEENE_PLUS:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_7;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SYMBOL:
          SlotName();
          break;
        case KLEENE_PLUS:
          jj_consume_token(KLEENE_PLUS);
          SlotName();
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(RBRACKET);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  static public DMAPPatternParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  static public Token token, jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[14];
  static private int[] jj_la1_0;
  static {
      jj_la1_0();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x4200,0x4200,0x80000,0x400000,0x108fc0,0x2000000,0x2000000,0x5800000,0x5800000,0x108fc0,0x108fc0,0x8fc0,0x1000100,0x1000100,};
   }

  public DMAPPatternParser(java.io.InputStream stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new DMAPPatternParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  public DMAPPatternParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new DMAPPatternParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  public DMAPPatternParser(DMAPPatternParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  public void ReInit(DMAPPatternParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  static final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.Vector jj_expentries = new java.util.Vector();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  static public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[27];
    for (int i = 0; i < 27; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 14; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 27; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  static final public void enable_tracing() {
  }

  static final public void disable_tracing() {
  }

}
