/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. DMAPPatternParser.jj */
/*@egen*/
/* The only non-default here is 'UNICODE_INPUT'; we want to support general Unicode character streams */
options {
   USER_TOKEN_MANAGER = false;
   USER_CHAR_STREAM = false;
   JAVA_UNICODE_ESCAPE = false;
   UNICODE_INPUT = true;                                  
}
PARSER_BEGIN(DMAPPatternParser)
package edu.uchsc.ccp.dmap.pattern;

import edu.uchsc.ccp.dmap.Pattern;

public class DMAPPatternParser/*@bgen(jjtree)*/implements DMAPPatternParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTDMAPPatternParserState jjtree = new JJTDMAPPatternParserState();

/*@egen*/

  public static String trimName(String name) {
  	return name.substring(1,name.length()-1);
  }
  public static String trimName(String name, int start) {
  	return name.substring(start,name.length()-1);
  }
  
  public static void main(String args[]) throws ParseException {
    System.out.println("Reading from standard input...");
    DMAPPatternParser parser = new DMAPPatternParser(System.in);
    try {
      ASTDMAPRuleSet n = parser.DMAPRuleSet();
      n.dump(""); 
      System.out.println("Thank you.");
    } catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    } 
  }

}

PARSER_END(DMAPPatternParser)

/* Skip white space (except in some cases, like strings) */
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* "Real" Tokens -- strings, SYMBOLs (i.e., non-quoted strings), regexs, frame names */

TOKEN :
{
 < REGEX1:
      "r'"
      (~["\'","\n","\r"])*
      "'"
  >
|< REGEX2:
      "r\""
      ( (~["\"","\n","\r"]) | ("\\" "\"") )*
      "\""
  >
| < SYMBOL: (<LETTER>|<DIGIT>|["'","_","-",":","/"])+ >
| < FRAME_NAME:
      "{"
      (   (~["\"","\\","\n","\r","{"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\"","{"]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "}"
  >
 | < STRING1:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
 | < STRING2:
      "'"
      (   (~["\'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "'"
  >
|
  < #LETTER:
      [
       "$",
       "A"-"Z",
       "_",
       "a"-"z",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "0"-"9",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/* COMMENTS */

TOKEN :
{
  <COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}


/* SEPARATORS */

TOKEN :
{
  < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < ARROW:     ":=" >
| < COMMA:     "," >
| < LPAREN:   "(" >
| < RPAREN:   ")" >
| < CLAUSE:   "@" >
}

/* Kleene operators */

TOKEN :
{
  < KLEENE_STAR: "*" >
| < KLEENE_PLUS: "+" >
| < ALTERNATION: "|" >
| < OPTIONAL:    "?" >

}

/* Production rules. */

/* A DMAPRuleSet is a set of DMAP rules */
ASTDMAPRuleSet DMAPRuleSet ():
{/*@bgen(jjtree) DMAPRuleSet */
  ASTDMAPRuleSet jjtn000 = new ASTDMAPRuleSet(JJTDMAPRULESET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DMAPRuleSet */
   try {
/*@egen*/  (DMAPRule() | Comment())*/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/  
   { return jjtn000; }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/ 
}

/* A Comment is a comment token up to line end */
ASTComment Comment () :
{/*@bgen(jjtree) Comment */
  ASTComment jjtn000 = new ASTComment(JJTCOMMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Comment */
        try {
/*@egen*/
	( <COMMENT> )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* A DMAPRule is a frame name, arrow, a set of patterns, ending with a semicolon */
/* 	  | Patterns() <SEMICOLON> ) */
ASTDMAPRule DMAPRule () :
{/*@bgen(jjtree) DMAPRule */
 ASTDMAPRule jjtn000 = new ASTDMAPRule(JJTDMAPRULE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token t = null;}
{/*@bgen(jjtree) DMAPRule */
        try {
/*@egen*/
	( t = <FRAME_NAME> {jjtn000.setBase(trimName(t.image));} <ARROW> Patterns() <SEMICOLON> )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/

	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* A set of patterns is one or more patterns separated by commas */
ASTPatterns Patterns() :
{/*@bgen(jjtree) Patterns */
  ASTPatterns jjtn000 = new ASTPatterns(JJTPATTERNS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Patterns */
        try {
/*@egen*/
	( Pattern() (<COMMA> Pattern())* )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* Pattern => PatternHead (& Clause)* */
ASTPattern Pattern () :
{/*@bgen(jjtree) Pattern */
  ASTPattern jjtn000 = new ASTPattern(JJTPATTERN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Pattern */
        try {
/*@egen*/
	( PatternComponent() (<CLAUSE> PatternComponent())* )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* A Pattern is one or more entries */
ASTPatternComponent PatternComponent () :
{/*@bgen(jjtree) PatternComponent */
  ASTPatternComponent jjtn000 = new ASTPatternComponent(JJTPATTERNCOMPONENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PatternComponent */
        try {
/*@egen*/
	(Entry())+/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ 
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* An entry is a base element, plus possible post-fixed operators or alternations. Optionally, surrounded by parens.*/
ASTEntry Entry () :
{/*@bgen(jjtree) Entry */
  ASTEntry jjtn000 = new ASTEntry(JJTENTRY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Entry */
        try {
/*@egen*/ 
	(OperatorEntry() [ (<ALTERNATION> OperatorEntry())+ {jjtn000.setOperatorType(Pattern.Operator.ALTERNATION);}
	                 ] )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ASTEntry OperatorEntry () :
{/*@bgen(jjtree) OperatorEntry */
  ASTOperatorEntry jjtn000 = new ASTOperatorEntry(JJTOPERATORENTRY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OperatorEntry */
        try {
/*@egen*/ 
	(SimpleEntry() [ (   <KLEENE_STAR> {jjtn000.setOperatorType(Pattern.Operator.STAR);} 
	                   | <KLEENE_PLUS> {jjtn000.setOperatorType(Pattern.Operator.PLUS);}
	                   | <OPTIONAL> {jjtn000.setOperatorType(Pattern.Operator.OPTIONAL);}
	                  ) ] )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ASTEntry SimpleEntry () :
{/*@bgen(jjtree) SimpleEntry */
  ASTSimpleEntry jjtn000 = new ASTSimpleEntry(JJTSIMPLEENTRY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SimpleEntry */
        try {
/*@egen*/ 
	( (BaseElement() {jjtn000.setOperatorType(Pattern.Operator.BASE);} ) |
	  ( <LPAREN> (Entry())+ <RPAREN> ) {jjtn000.setOperatorType(Pattern.Operator.SEQUENCE);} )/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/* Base element is a string, symbol, regular expression, frame name, or path */
ASTBaseElement BaseElement () :
{/*@bgen(jjtree) BaseElement */
  ASTBaseElement jjtn000 = new ASTBaseElement(JJTBASEELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null;}
{/*@bgen(jjtree) BaseElement */
        try {
/*@egen*/ 
	( t = <STRING1> {jjtn000.setEntryType(ASTBaseElement.EntryType.STRING);
	                jjtn000.setImage(trimName(t.image));}
	| t = <STRING2> {jjtn000.setEntryType(ASTBaseElement.EntryType.STRING);
	                jjtn000.setImage(trimName(t.image));}
	| t = <SYMBOL> {jjtn000.setEntryType(ASTBaseElement.EntryType.STRING);
	                jjtn000.setImage(t.image);}
	| t = <REGEX1>  {jjtn000.setEntryType(ASTBaseElement.EntryType.REGEX);
	                jjtn000.setImage(trimName(t.image,2));}
  | t = <REGEX2>  {jjtn000.setEntryType(ASTBaseElement.EntryType.REGEX);
	                jjtn000.setImage(trimName(t.image,2));}
	| t = <FRAME_NAME> {jjtn000.setEntryType(ASTBaseElement.EntryType.FRAME_NAME);
	                jjtn000.setImage(trimName(t.image));}
	| Path() {jjtn000.setEntryType(ASTBaseElement.EntryType.PATH);} )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

ASTSlotName SlotName () : 
{/*@bgen(jjtree) SlotName */
  ASTSlotName jjtn000 = new ASTSlotName(JJTSLOTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t = null; }
{/*@bgen(jjtree) SlotName */
   try {
/*@egen*/  ( t = <SYMBOL> {jjtn000.setName(t.image);} )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {return jjtn000; }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}
/* A path is one or more slot names  surrounded by brackets */
ASTPath Path () :
{/*@bgen(jjtree) Path */
  ASTPath jjtn000 = new ASTPath(JJTPATH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ }
{/*@bgen(jjtree) Path */
  try {
/*@egen*/
  ( <LBRACKET> SlotName() (SlotName() | ("+" SlotName()))* <RBRACKET> )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


